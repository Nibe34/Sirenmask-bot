
================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\run.py
================================================================================

from telegram.ext import ApplicationBuilder
from sirenmask.bot.handlers import register_handlers
from sirenmask.config import TELEGRAM_TOKEN

def main():
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    register_handlers(app)
    app.run_polling()

if __name__ == "__main__":
    main()

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\config.py
================================================================================

import os
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
ALLOWED_USERS = list(map(int, os.getenv("ALLOWED_USERS", "").split(",")))
VOICE_MODELS_PATH = os.getenv("VOICE_MODELS_PATH", "models")
TEMP_PATH = "temp/"

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\__init__.py
================================================================================


================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\bot\handlers.py
================================================================================

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from .whitelist import is_authorized
from .voice_utils import process_voice
from sirenmask.rvc_engine.model_manager import get_available_models
from sirenmask.bot.state import get_user_model, set_user_model, set_user_settings
from sirenmask.bot.state import get_user_settings, reset_user_settings

default_settings = {
    "f0_up_key": 2,
    "index_rate": 0.8,
    "filter_radius": 7,
    "resample_sr": 48000,
    "rms_mix_rate": 0.25,
    "protect": 0.5
}


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_authorized(update.effective_user.id):
        await update.message.reply_text("🚫 Доступ обмежено.")
        return
    await update.message.reply_text("Привіт! Обери голос через /select_voice, потім надішли voice.")


async def select_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_authorized(update.effective_user.id):
        return

    models = get_available_models()
    if not models:
        await update.message.reply_text("⚠️ Немає доступних голосів.")
        return

    keyboard = [
        [InlineKeyboardButton(model_name, callback_data=model_name)]
        for model_name in models
    ]

    await update.message.reply_text(
        "🎙️ Обери голос:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


async def set_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    model_name = query.data

    set_user_model(user_id, model_name)  # ✅ збереження в файл

    await query.answer()
    await query.edit_message_text(f"✅ Голос встановлено: {model_name}")


async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not is_authorized(user_id):
        return

    model = get_user_model(user_id)  # ✅ отримуємо збережену модель
    if not model:
        await update.message.reply_text("Спочатку оберіть голос через /select_voice")
        return

    voice_file = await update.message.voice.get_file()
    settings = get_user_settings(user_id)
    output_path = await process_voice(voice_file, model, settings)
    await update.message.reply_voice(voice=open(output_path, "rb"))


def register_handlers(app):
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("select_voice", select_voice))
    app.add_handler(CallbackQueryHandler(set_voice))
    app.add_handler(MessageHandler(filters.VOICE, handle_voice))
    app.add_handler(CommandHandler("voice_settings", voice_settings))


async def voice_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not is_authorized(user_id):
        return

    args = context.args
    if not args:
        # показати поточні
        current = get_user_settings(user_id) or default_settings
        text = "🎛 Поточні параметри:\n" + "\n".join(
            f"{k}: {v}" for k, v in current.items()
        )
        text += "\n\nЩоб змінити: /voice_settings f0_up_key=3"
        text += "\nЩоб скинути до стандартних: /voice_settings reset"
        await update.message.reply_text(text)
        return

    if args[0] == "reset":
        reset_user_settings(user_id)
        await update.message.reply_text("✅ Параметри скинуто до стандартних.")
        return

    # зміна параметра
    try:
        key, value = args[0].split("=")
        if key not in default_settings:
            await update.message.reply_text("⛔ Невідомий параметр.")
            return
        value = type(default_settings[key])(value)
        current = get_user_settings(user_id) or default_settings.copy()
        current[key] = value
        set_user_settings(user_id, current)
        await update.message.reply_text(f"✅ Параметр {key} встановлено в {value}")
    except Exception as e:
        await update.message.reply_text("⚠️ Помилка зміни параметра.")
================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\bot\state.py
================================================================================

import json
import os

STATE_FILE = "user_state.json"

# Завантаження стану з підтримкою старого формату
if os.path.exists(STATE_FILE):
    with open(STATE_FILE, "r", encoding="utf-8") as f:
        user_state = json.load(f)
    # 🔄 Міграція зі старого формату: якщо значення — рядок, обгортаємо в словник
    for uid, value in list(user_state.items()):
        if isinstance(value, str):
            user_state[uid] = {"model": value}
    # зберігаємо одразу, якщо була міграція
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(user_state, f, ensure_ascii=False, indent=2)
else:
    user_state = {}

def save_state():
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(user_state, f, ensure_ascii=False, indent=2)

def get_user_model(user_id: int) -> str | None:
    return user_state.get(str(user_id), {}).get("model")

def set_user_model(user_id: int, model_name: str):
    uid = str(user_id)
    if uid not in user_state:
        user_state[uid] = {}
    user_state[uid]["model"] = model_name
    save_state()

def get_user_settings(user_id: int) -> dict:
    return user_state.get(str(user_id), {}).get("settings", {})

def set_user_settings(user_id: int, settings: dict):
    uid = str(user_id)
    if uid not in user_state:
        user_state[uid] = {}
    user_state[uid]["settings"] = settings
    save_state()

def reset_user_settings(user_id: int):
    uid = str(user_id)
    if uid in user_state and "settings" in user_state[uid]:
        del user_state[uid]["settings"]
        save_state()

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\bot\voice_utils.py
================================================================================

import os
import uuid
from sirenmask.config import TEMP_PATH
from sirenmask.rvc_engine.rvc_wrapper import convert_voice
from sirenmask.utils.audio import convert_ogg_to_wav

async def process_voice(file, model_name, user_settings=None):
    uid = uuid.uuid4().hex
    ogg_path = os.path.join(TEMP_PATH, f"{uid}.ogg")
    wav_path = ogg_path.replace(".ogg", ".wav")
    output_path = ogg_path.replace(".ogg", "_converted.wav")

    await file.download_to_drive(ogg_path)
    convert_ogg_to_wav(ogg_path, wav_path)
    convert_voice(wav_path, model_name, output_path, user_settings)
    return output_path

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\bot\whitelist.py
================================================================================

from sirenmask.config import ALLOWED_USERS

def is_authorized(user_id: int) -> bool:
    return user_id in ALLOWED_USERS

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\bot\__init__.py
================================================================================


================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\rvc_engine\model_manager.py
================================================================================

import os
from sirenmask.config import VOICE_MODELS_PATH

def get_available_models():
    return [
        name for name in os.listdir(VOICE_MODELS_PATH)
        if os.path.isdir(os.path.join(VOICE_MODELS_PATH, name))
    ]

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\rvc_engine\postprocess.py
================================================================================

import os
import subprocess
import librosa
import numpy as np
import soundfile as sf

def postprocess_audio(audio_path: str, output_path: str):
    # Постобробка аудіо: нормалізація + шумозаглушення (через ffmpeg)
    y, sr = librosa.load(audio_path, sr=None)
    peak = np.max(np.abs(y))
    if peak > 0:
        y = y / peak * 0.95

    temp_norm = output_path.replace(".wav", "_norm.wav")
    sf.write(temp_norm, y, sr)

    command = [
        "ffmpeg", "-y",
        "-i", temp_norm,
        "-af", "afftdn=nf=-25",
        output_path
    ]
    subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    os.remove(temp_norm)

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\rvc_engine\rvc_wrapper.py
================================================================================

import sys
import os
from types import SimpleNamespace
import torch
import soundfile as sf

from sirenmask.config import VOICE_MODELS_PATH
sys.path.append(os.path.abspath("rvc_lib"))
from rvc_lib.infer.modules.vc.modules import VC
from sirenmask.rvc_engine.postprocess import postprocess_audio


vc_model = None
current_model_name = None

def convert_voice(input_path, model_name, output_path, user_settings=None):
    global vc_model, current_model_name

    model_dir = os.path.join(VOICE_MODELS_PATH, model_name)
    model_pth = next((f for f in os.listdir(model_dir) if f.endswith(".pth")), None)
    index_file = next((f for f in os.listdir(model_dir) if f.endswith(".index.pkl")), "")

    if not model_pth:
        raise FileNotFoundError("Модель .pth не знайдено в: " + model_dir)

    # Тепер просто ім’я файлу
    model_pth_filename = model_pth
    index_path = os.path.join(model_dir, index_file) if index_file else ""

    # Ініціалізація, якщо нова модель
    if vc_model is None or current_model_name != model_pth_filename:
        config = SimpleNamespace(
            is_half=False,
            device="cuda" if torch.cuda.is_available() else "cpu",
            x_pad=1,
            x_query=10,
            x_center=60,
            x_max=65
        )
        vc_model = VC(config)
        current_model_name = model_pth_filename

        os.environ["weight_root"] = VOICE_MODELS_PATH  # це важливо
        print(f"[✅] Завантаження моделі: {model_pth_filename}")
        relative_model_path = os.path.join(model_name, model_pth_filename)
        os.environ["weight_root"] = VOICE_MODELS_PATH
        os.environ["index_root"] = VOICE_MODELS_PATH
        os.environ["rmvpe_root"] = os.path.join("rvc_lib", "assets", "rmvpe")
        vc_model.get_vc(relative_model_path)

    settings = user_settings or {}
    info, output = vc_model.vc_single(
        sid=0,
        input_audio_path=input_path,
        f0_up_key=settings.get("f0_up_key", 2),
        f0_file=None,
        f0_method="rmvpe",
        file_index=index_path,
        file_index2="",
        index_rate=settings.get("index_rate", 0.8),
        filter_radius=settings.get("filter_radius", 7),
        resample_sr=settings.get("resample_sr", 48000),
        rms_mix_rate=settings.get("rms_mix_rate", 0.25),
        protect=settings.get("protect", 0.5)
    )

    if "Success" in info:
        sr, audio = output
        temp_path = output_path.replace(".wav", "_raw.wav")
        sf.write(temp_path, audio, sr)
        postprocess_audio(temp_path, output_path)
        os.remove(temp_path)
    else:
        raise RuntimeError(f"🔴 Конверсія не вдалася: {info}")

================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\rvc_engine\__init__.py
================================================================================


================================================================================
# Файл: C:\Users\Nibe\Documents\GitHub\Sirenmask-bot\sirenmask\utils\audio.py
================================================================================

import os

def convert_ogg_to_wav(ogg_path, wav_path):
    os.system(f"ffmpeg -y -i \"{ogg_path}\" -ar 44100 -ac 1 \"{wav_path}\"")
